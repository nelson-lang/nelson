%=============================================================================
% Copyright (c) 2016-present Allan CORNET (Nelson)
%=============================================================================
% This file is part of the Nelson.
%=============================================================================
% LICENCE_BLOCK_BEGIN
% SPDX-License-Identifier: LGPL-3.0-or-later
% LICENCE_BLOCK_END
%=============================================================================
assert_checkerror('arrayfun()', _('Wrong number of input arguments.'));
%=============================================================================
fun = @(in1, in2) in1+in2;
C = [1 2 3; 4 5 6];
C(:,:,2) = [7 8 9; 10 11 12];
D = [1 2+2i 3; 4+1 5 6];
D(:,:,2) = [1+i 2 3; 4+1 5 6];
R = arrayfun(fun, C, D);
assert_isequal(size(R), [2     3     2]);
REF_1 = [2.0000 + 0.0000i   4.0000 + 2.0000i   6.0000 + 0.0000i;
9.0000 + 0.0000i  10.0000 + 0.0000i  12.0000 + 0.0000i];
assert_isequal(R(:,:,1), REF_1);
REF_2 = [   8.0000 + 1.0000i  10.0000 + 0.0000i  12.0000 + 0.0000i;
15.0000 + 0.0000i  16.0000 + 0.0000i  18.0000 + 0.0000i];
assert_isequal(R(:,:,2), REF_2);
%=============================================================================
fun = @(in1, in2) in1+in2;
A = ones(3);
B = 2*ones(4);
assert_checkerror('R = arrayfun(fun, A, B)', _('Same size expected.'));
%=============================================================================
R = arrayfun (@atan2, [1, 0], [0, 1]);
REF = atan2([1,0], [0,1]);
assert_isequal(R, REF);
%=============================================================================
assert_checkerror('[R1, R2] = arrayfun (@atan2, [1, 0], [0, 1]);', _('Wrong number of output arguments.'))
%=============================================================================
fun = @(in1, in2) in1+in2;
A = sparse([1 2 3 4 5],[1 2 3 4 5],[1 2 3 4 5]);
B = ones(5);
assert_checkerror('R = arrayfun(fun, A, B)', _('Sparse inputs are not supported.'));
%=============================================================================
fun = @(in1, in2) str2num(in2);
errorHandle = @(s, in1, in2)  10; 
R  = arrayfun (fun, 1:4, 4:7, 'ErrorHandler', errorHandle);
REF = [10 10 10 10];
assert_isequal(R, REF);
%=============================================================================
fun = @(a, b) [a, b];
assert_checkerror('R = arrayfun(fun, ''abc'', ''def'')', _('Non-scalar in Uniform output.'));
%=============================================================================
fun = @(st) ((st.a) +(st.b));
s(1, 1).a = 1;
s(1, 2).a = 2;
s(2, 1).a = 3;
s(2, 2).a = 4;
s(3, 1).a = 3;
s(3, 2).a = 4;
s(1, 1).b = 5;
s(1, 2).b = 6;
s(2, 1).b = 7;
s(2, 2).b = 8;
s(3, 1).b = 7;
s(3, 2).b = 8;
R = arrayfun(fun , s);
REF = [6     8;
10    12;
10    12];
assert_isequal(R, REF);
%=============================================================================
fun = @(a) a.a+a.b;
s(1).a = 1;
s(2).a = 2;
s(3).a = 3;
s(1).b = 1;
s(2).b = 2;
s(3).b = 3;
R = arrayfun(fun , s);
REF = [2     8;
4    12;
6    12];
assert_isequal(R, REF);
%=============================================================================
R = arrayfun(@(a, b) [a, b], '1234', 'abcd', 'uniformoutput', 0);
REF = {'1a', '2b', '3c', '4d'};
assert_isequal(R, REF);
%=============================================================================
fun = @(in1, in2) in1+in2;
C = [1 2 3; 4 5 6];
C(:,:,2) = [7 8 9; 10 11 12];
D = [1 2+2i 3; 4+1 5 6];
D(:,:,2) = [1+i 2 3; 4+1 5 6];
R = arrayfun(fun, C, D);
assert_isequal(R(:,:,1), [2.0000 + 0.0000i   4.0000 + 2.0000i   6.0000 + 0.0000i; 
   9.0000 + 0.0000i  10.0000 + 0.0000i  12.0000 + 0.0000i]);
assert_isequal(R(:,:,2), [8.0000 + 1.0000i  10.0000 + 0.0000i  12.0000 + 0.0000i;
  15.0000 + 0.0000i  16.0000 + 0.0000i  18.0000 + 0.0000i]);
%=============================================================================
fun = @(in1, in2) {in1+in2; in1-in2; max(in1, in2)};
assert_checkerror('C = arrayfun(fun, [1:3;5:7], [2:4;8:10], ''UniformOutput'', true);', _('Non-scalar in Uniform output.'));
%=============================================================================
fun = @(in1, in2)  in1+in2;
assert_checkerror('R = arrayfun(fun, 10, [2:4;8:10])',_('Same size expected.'));
%=============================================================================
fun = @(in1, in2)  in1+in2;
R = arrayfun(fun, [1:3;5:7], [2:4;8:10]);
REF = [     3     5     7;
    13    15    17];
assert_isequal(R, REF);
%=============================================================================
R = arrayfun('sqrt', 1:4);
REF = [    1.0000    1.4142    1.7321    2.0000];
assert_isapprox(R, REF, 1e-4);
%=============================================================================
assert_checkerror('R = arrayfun(''sqrt'', 1:4, 1:4)', _('Wrong number of input arguments.'));
%=============================================================================
assert_checkerror('R = arrayfun(''dummyFun'',1:4)', _('Unknown function name.'));
%=============================================================================
fun = @(in1, in2) in1+in2;
C = [1 2 3; 4 5 6];
C(:,:,2) = [7 8 9; 10 11 12];
D = [1 2+2i 3; 4+1 5 6];
D(:,:,2) = [1+i 2 3; 4+1 5 6];
R = arrayfun(fun, C, D, 'uniformoutput', 1);
REF_1 = [2.0000 + 0.0000i   4.0000 + 2.0000i   6.0000 + 0.0000i;
   9.0000 + 0.0000i  10.0000 + 0.0000i  12.0000 + 0.0000i];
REF_2 = [8.0000 + 1.0000i  10.0000 + 0.0000i  12.0000 + 0.0000i;
  15.0000 + 0.0000i  16.0000 + 0.0000i  18.0000 + 0.0000i];
assert_isequal(R(:,:,1), REF_1);
assert_isequal(R(:,:,2), REF_2);
%=============================================================================

