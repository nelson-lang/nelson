//=============================================================================
// Copyright (c) 2016-present Allan CORNET (Nelson)
//=============================================================================
// This file is part of the Nelson.
//=============================================================================
// LICENCE_BLOCK_BEGIN
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// Alternatively, you can redistribute it and/or
// modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation; either version 2 of
// the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program. If not, see <http://www.gnu.org/licenses/>.
// LICENCE_BLOCK_END
//=============================================================================
assert_isequal(nargin('mean'), 4)
assert_isequal(nargout('mean'), 1)
//=============================================================================
R = mean([complex(1,NaN), complex(1, 2)], 'omitnan');
assert_isequal(R, complex(1, 2));
//=============================================================================
R = mean([complex(1,NaN), complex(1, 2)], 'includenan');
assert_isequal(R, complex(1, NaN));
//=============================================================================
R = mean([complex(1,NaN), complex(NaN,2)], 'omitnan');
assert_isequal(R, NaN);
//=============================================================================
R = mean([complex(1,NaN), complex(NaN,2)], 'includenan');
assert_isequal(R, complex(NaN, NaN));
//=============================================================================
R = mean ([1 2], 1);
assert_isequal(R, [1 2]);
//=============================================================================
R = mean ([1 2], 2);
assert_isequal(R, 1.5);
//=============================================================================
R = mean ([1 2], 3);
assert_isequal(R, [1 2]);
//=============================================================================
R = mean(single([1 0 1 1]));
assert_isequal(R, single(0.75));
//=============================================================================
R = mean(logical ([1 0 1 1]));
assert_isequal(R, 0.75)
//=============================================================================
R = mean([4 4 2]);
assert_isequal(R, 3+ 1/3);
//=============================================================================
R = mean ([2 8]);
assert_isequal(R, 5);
//=============================================================================
R = mean(repmat(0.1, 1, 10000));
assert_isapprox(R, 0.1000, 1e-4);
//=============================================================================
X = -100:100;
R = mean(X);
assert_isequal(R, 0);
//=============================================================================
Y = X';
R = mean(Y);
assert_isequal(R, 0);
//=============================================================================
Z = [Y, Y + 100];
R = mean(Z);
assert_isequal(R, [0 100]);
//=============================================================================
M = [0 1 1; 2 3 2; 1 3 2; 4 2 2];
R = mean(M);
REF = [1.7500    2.2500    1.7500];
assert_isapprox(R, REF, 1e-4);
//=============================================================================
R = mean(M, 'all');
REF = 1.9167;
assert_isapprox(R, REF, 1e-4);
//=============================================================================
R = mean(M, 1);
REF = [1.7500    2.2500    1.7500];
assert_isapprox(R, REF, 1e-4);
//=============================================================================
R = mean(M, 2);
REF = [0.6667;2.3333;2.0000;2.6667];
assert_isapprox(R, REF, 1e-4);
//=============================================================================
R = mean(M, 3);
assert_isequal(R, M);
//=============================================================================
M = [1:24];
M = reshape(M, 3, 2, 4);
R = mean(M, 1);
assert_isequal(R(:,:,1), [ 2, 5]);
assert_isequal(R(:,:,2), [ 8, 11]);
assert_isequal(R(:,:,3), [ 14, 17]);
assert_isequal(R(:,:,4), [ 20, 23]);
//=============================================================================
M = [1:24];
M = reshape(M, 3, 2, 4);
R = mean(M, 'all');
assert_isequal(R, 12.5);
//=============================================================================
A = single(ones(10, 1));
R = mean(A, 'native');
assert_isequal(R, single(1));
//=============================================================================
A = single(ones(10, 1));
R = mean(A, 'default');
assert_isequal(R, single(1));
//=============================================================================
A = single(ones(10, 1));
R = mean(A, 'double');
assert_isequal(R, double(1));
//=============================================================================
A = [1 0 0 1 NaN 1 NaN 0];
R = mean(A, 'omitnan');
assert_isequal(R, 0.5);
//=============================================================================
A = [1 0 0 1 NaN 1 NaN 0];
R = mean(A, 'includenan');
assert_isequal(R, NaN);
//=============================================================================
