%=============================================================================
% Copyright (c) 2016-present Allan CORNET (Nelson)
%=============================================================================
% This file is part of Nelson.
%=============================================================================
% LICENCE_BLOCK_BEGIN
% SPDX-License-Identifier: LGPL-3.0-or-later
% LICENCE_BLOCK_END
%=============================================================================
assert_isequal(nargin('num2bin'), 1)
assert_isequal(nargout('num2bin'), 1)
%=============================================================================
rng('default')
%=============================================================================
assert_isequal(num2bin(logical(0)), '0')
assert_isequal(num2bin(logical(1)), '1')
%=============================================================================
assert_isequal(num2bin(int8(0)),  '0000000000000000000000000000000000000000000000000000000000000000')
assert_isequal(num2bin(uint8(0)), '0000000000000000000000000000000000000000000000000000000000000000')
%=============================================================================
assert_isequal(num2bin(int16(0)),  '0000000000000000000000000000000000000000000000000000000000000000')
assert_isequal(num2bin(uint16(0)), '0000000000000000000000000000000000000000000000000000000000000000')
%=============================================================================
assert_isequal(num2bin(int32(0)),  '0000000000000000000000000000000000000000000000000000000000000000')
assert_isequal(num2bin(uint32(0)), '0000000000000000000000000000000000000000000000000000000000000000')
%=============================================================================
assert_isequal(num2bin(int64(0)),  '0000000000000000000000000000000000000000000000000000000000000000')
assert_isequal(num2bin(uint64(0)), '0000000000000000000000000000000000000000000000000000000000000000')
%=============================================================================
assert_isequal(num2bin(single(0)), '00000000000000000000000000000000')
assert_isequal(num2bin(double(0)), '0000000000000000000000000000000000000000000000000000000000000000')
%=============================================================================
assert_isequal(num2bin(intmax('int8')), '0100000001011111110000000000000000000000000000000000000000000000')
assert_isequal(num2bin(intmax('uint8')), '0100000001101111111000000000000000000000000000000000000000000000')
%=============================================================================
assert_isequal(num2bin(intmax('int16')), '0100000011011111111111111100000000000000000000000000000000000000')
assert_isequal(num2bin(intmax('uint16')), '0100000011101111111111111110000000000000000000000000000000000000')
%=============================================================================
assert_isequal(num2bin(intmax('int32')), '0100000111011111111111111111111111111111110000000000000000000000')
assert_isequal(num2bin(intmax('uint32')), '0100000111101111111111111111111111111111111000000000000000000000')
%=============================================================================
assert_isequal(num2bin(intmax('int64')), '0100001111100000000000000000000000000000000000000000000000000000')
assert_isequal(num2bin(intmax('uint64')), '0100001111110000000000000000000000000000000000000000000000000000')
%=============================================================================
assert_isequal(num2bin(intmin('int8')), '1100000001100000000000000000000000000000000000000000000000000000')
%=============================================================================
assert_isequal(num2bin(intmin('int16')), '1100000011100000000000000000000000000000000000000000000000000000')
%=============================================================================
assert_isequal(num2bin(intmin('int32')), '1100000111100000000000000000000000000000000000000000000000000000')
%=============================================================================
assert_isequal(num2bin(intmin('int64')), '1100001111100000000000000000000000000000000000000000000000000000')
%=============================================================================
assert_isequal(num2bin(Inf), '0111111111110000000000000000000000000000000000000000000000000000')
assert_isequal(num2bin(-Inf), '1111111111110000000000000000000000000000000000000000000000000000')
%=============================================================================
assert_isequal(num2bin(NaN),  '0111111111111000000000000000000000000000000000000000000000000000')
assert_isequal(num2bin(-NaN),  '1111111111111000000000000000000000000000000000000000000000000000')
%=============================================================================
assert_isequal(num2bin(single(Inf)),'01111111100000000000000000000000')
assert_isequal(num2bin(single(-Inf)),  '11111111100000000000000000000000')
%=============================================================================
assert_isequal(num2bin(single(NaN)), '01111111110000000000000000000000')
assert_isequal(num2bin(single(-NaN)), '11111111110000000000000000000000')
%=============================================================================
assert_isequal(num2bin(pi),  '0100000000001001001000011111101101010100010001000010110100011000')
assert_isequal(num2bin(single(pi)),  '01000000010010010000111111011011')
%=============================================================================
assert_isequal(num2bin(eps), '0011110010110000000000000000000000000000000000000000000000000000')
assert_isequal(num2bin(eps('single')), '00110100000000000000000000000000')
%=============================================================================
assert_isequal(num2bin(1), '0011111111110000000000000000000000000000000000000000000000000000')
assert_isequal(num2bin(-1),  '1011111111110000000000000000000000000000000000000000000000000000')
%=============================================================================
REF = ['0011111111110000000000000000000000000000000000000000000000000000';
'0000000000000000000000000000000000000000000000000000000000000000';
'0000000000000000000000000000000000000000000000000000000000000000';
'0011111111110000000000000000000000000000000000000000000000000000';
'0000000000000000000000000000000000000000000000000000000000000000';
'0000000000000000000000000000000000000000000000000000000000000000'];
assert_isequal(num2bin(eye(2, 3)), REF);
%=============================================================================
REF = ['0011111111101010000100100011011101101000100010101011101001111011';
'0011111111101100111111000011111101011111010101110000110001111101';
'0011111111000000010000010001101010011111100000000111101101111100';
'0011111111101101001110100110000000000000111000100101011010111111';
'0011111111100100001111000100100101110101001110111001000000100100';
'0011111110111000111110000110100001110001100000101101010011000000'];
R = num2bin(rand(2, 3));
assert_isequal(R, REF);
%=============================================================================
REF = ['0011111111110000000000000000000000000000000000000000000000000000';
'0000000000000000000000000000000000000000000000000000000000000000';
'0000000000000000000000000000000000000000000000000000000000000000';
'0011111111110000000000000000000000000000000000000000000000000000';
'0000000000000000000000000000000000000000000000000000000000000000';
'0000000000000000000000000000000000000000000000000000000000000000'];
R = num2bin(sparse(eye(2, 3)));
assert_isequal(R, REF);
%=============================================================================
assert_checkerror('num2bin(i)', _('First argument must be real.'))
msg = sprintf(_('Check for incorrect argument data type or missing argument in call to function ''%s''.'), 'num2bin');
assert_checkerror('num2bin(''i'')', msg);
%=============================================================================
