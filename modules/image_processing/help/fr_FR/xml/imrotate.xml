<?xml version="1.0" encoding="UTF-8" ?>
<xmldoc>
    <copyright>SPDX-License-Identifier: LGPL-3.0</copyright>
    <language>fr_FR</language>
    <keyword>imrotate</keyword>
    <short_description
  >Fait pivoter une image d'un angle spécifié</short_description>
    <syntax>
        <syntax_item>J = imrotate(I, angle)</syntax_item>
        <syntax_item>J = imrotate(I, angle, method)</syntax_item>
        <syntax_item>J = imrotate(I, angle, method, bbox)</syntax_item>
    </syntax>
    <param_input>
        <param_input_item>
                        <param_name>I</param_name>
                        <param_description
      >Image d'entrée : image 2D en niveaux de gris ou image 3D RGB de classe uint8, uint16, int16, single ou double</param_description>
        </param_input_item>
        <param_input_item>
                        <param_name>angle</param_name>
                        <param_description
      >Angle de rotation en degrés (scalaire). Les valeurs positives tournent dans le sens anti-horaire, les valeurs négatives dans le sens horaire</param_description>
        </param_input_item>
        <param_input_item>
                        <param_name>method</param_name>
                        <param_description
      >Méthode d'interpolation (optionnelle, par défaut : 'bilinear') :
                - 'nearest' : interpolation au plus proche voisin
                - 'bilinear' : interpolation bilinéaire (par défaut)
                - 'bicubic' : interpolation bicubique</param_description>
        </param_input_item>
        <param_input_item>
            <param_name>bbox</param_name>
            <param_description
      >Option de boîte englobante (optionnelle, par défaut : 'loose') :
        - 'loose' : dimensionne la sortie pour contenir l'image tournée en entier
        - 'crop' : recadre la sortie à la même taille que l'image d'entrée</param_description>
        </param_input_item>
    </param_input>
    <param_output>
        <param_output_item>
            <param_name>J</param_name>
            <param_description
      >Rotated image, same class as input image I</param_description>
        </param_output_item>
    </param_output>
    <description>
                <p>La fonction <b
      >imrotate</b> fait pivoter une image de l'angle spécifié autour de son centre. La rotation utilise la méthode d'interpolation spécifiée.</p>
                <p
    >La fonction prend en charge divers formats d'images, y compris niveaux de gris et RGB. L'image de sortie conserve le même type de données que l'image d'entrée.</p>
                <p
    >Pour les angles multiples de 90°, la rotation est effectuée exactement sans interpolation afin de préserver la qualité. Pour les autres angles, l'interpolation est utilisée pour estimer les valeurs de pixels aux coordonnées non entières.</p>
                <p
    >L'option de boîte englobante contrôle la taille de l'image de sortie :</p>
        <ul>
            <li>
                <b
        >'loose'</b> : l'image de sortie est dimensionnée pour contenir l'image tournée en entier. Cela peut donner une image plus grande que l'entrée.</li>
                <li><b
        >'crop'</b> : l'image de sortie est recadrée à la même taille que l'image d'entrée. Des parties de l'image tournée peuvent être coupées.</li>
                </ul>
                <p
    >Les pixels de fond (zones non couvertes par l'image tournée) sont remplis de zéros.</p>
                <p />
                <p>Note:</p>
                <p>
                    <b
      >Note de performance :</b> pour des rotations exactes de 90° (0°, 90°, 180°, 270°), la fonction utilise des algorithmes optimisés qui préservent les valeurs exactes des pixels sans interpolation.</p>
                    <p>
                        <b
      >Utilisation mémoire :</b> en utilisant 'loose' avec de grands angles de rotation, l'image de sortie peut être significativement plus grande que l'entrée. Envisagez 'crop' pour les applications avec contrainte mémoire.</p>
                        <p>
                            <b
      >Conservation du type de données :</b> l'image de sortie conserve le même type de données que l'entrée. Pour les entrées en virgule flottante, les valeurs de pixels peuvent dépasser la plage habituelle [0,1] après interpolation.</p>
                            <p>
                                <b
      >Convention d'angle :</b> les angles positifs tournent dans le sens anti-horaire, conformément à la convention mathématique standard. Cela peut être l'inverse de certaines applications de traitement d'images qui utilisent la rotation positive dans le sens horaire.</p>
                                <p />
                                <p>Limitations:</p>
                                <p
    >L'image d'entrée doit être 2D (niveaux de gris) ou 3D (RGB). Les autres espaces colorimétriques ne sont pas directement supportés.</p>
                                <p
    >La rotation est toujours effectuée autour du centre de l'image. Les rotations hors-centre requièrent un prétraitement supplémentaire.</p>
                                <p
    >Pour des angles très grands (>360°), considérez l'utilisation de l'arithmétique modulo pour normaliser l'angle et améliorer les performances.</p>
                                <p
    >L'interpolation bicubique peut produire des artefacts de dépassement près des contours nets de l'image.</p>
                            </description>
                            <used_function />
                            <bibliography />
                            <examples>
                                <example_item>
                                    <example_item_type
      >nelson</example_item_type>
                                    <example_item_description
      >Interactive rotation visualization  (Part 1)</example_item_description>
                                    <example_item_data
        runnable="adv-cli"
      ><![CDATA[% Create a test image with clear directional features
I = zeros(100, 100, 'uint8');

% Add arrow-like pattern to show rotation clearly
I(40:60, 20:80) = 128;  % Horizontal bar
I(45:55, 15:85) = 255;  % Arrow shaft
I(50, 85:95) = 255;     % Arrow tip
I(45:49, 80:84) = 255;  % Upper arrow head
I(51:55, 80:84) = 255;  % Lower arrow head

% Show original
figure('Name', 'Rotation Progression', 'Position', [0 0 1024 768]);
subplot(2, 4, 1);
imagesc(I);
colormap(gray);
axis equal; axis tight;
title('Original (0°)');

% Show rotation progression
angles = [15, 30, 45, 60, 90, 120, 180];

for i = 1:length(angles)
    J = imrotate(I, angles(i), 'bilinear');
    
    subplot(2, 4, i + 1);
    imagesc(J);
    colormap(gray);
    axis equal; axis tight;
    title(sprintf('%d°', angles(i)));
    
    % Print rotation statistics
    fprintf('Angle %3d°: size %dx%d, non-zero pixels: %d\n', ...
            angles(i), size(J, 1), size(J, 2), sum(J(:) > 0));
end
        ]]></example_item_data>
                                    <example_item_img
        src="../images/imrotate_1.svg"
        align="middle"
        generate="true"
      />
                                </example_item>
                                <example_item>
                                    <example_item_type
      >nelson</example_item_type>
                                    <example_item_description
      >Interactive rotation visualization (Part 2)</example_item_description>
                                    <example_item_data
      ><![CDATA[% Create a test image with clear directional features
I = zeros(100, 100, 'uint8');

% Add arrow-like pattern to show rotation clearly
I(40:60, 20:80) = 128;  % Horizontal bar
I(45:55, 15:85) = 255;  % Arrow shaft
I(50, 85:95) = 255;     % Arrow tip
I(45:49, 80:84) = 255;  % Upper arrow head
I(51:55, 80:84) = 255;  % Lower arrow head

% Demonstrate interpolation effects with zoomed view
figure('Name', 'Interpolation Methods Comparison','Position', [0 0 1024 768]);
I_small = I(40:70, 40:70);  % Crop a section for detailed view

methods = {'nearest', 'bilinear', 'bicubic'};
for i = 1:length(methods)
    J = imrotate(I_small, 30, methods{i});
    
    subplot(1, 3, i);
    imagesc(J);
    colormap(gray);
    axis equal; axis tight;
    title(sprintf('%s interpolation', methods{i}));
end
        ]]></example_item_data>
                                    <example_item_img
        src="../images/imrotate_2.svg"
        align="middle"
        generate="true"
      />
                                </example_item>
                            </examples>
                            <see_also>
                                <see_also_item>
                                    <link
        linkend="${image_processing}imresize"
      >imresize</link>
                                </see_also_item>
                                <see_also_item>
                                    <link
        linkend="${image_processing}imshow"
      >imshow</link>
                                </see_also_item>
                            </see_also>
                            <history>
                                <history_item>
                                    <history_version>1.14.0</history_version>
                                    <history_description
      >version initiale</history_description>
                                </history_item>
                            </history>
                            <authors>
                                <author_item>Allan CORNET</author_item>
                            </authors>
                        </xmldoc>
